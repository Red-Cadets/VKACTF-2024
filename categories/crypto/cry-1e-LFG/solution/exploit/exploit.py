from bs4 import BeautifulSoup
import requests
from LFG import LaggedFibonacciGenerator
from utils import combinations
from itertools import combinations as comb
from sage.all import *
import re


class Interaction:
    def __init__(self):
        self.session = requests.Session()
        self.BASE_URL = "http://pocker.vkactf.ru/"

    def register(self, gang, age, bankroll):
        url = f"{self.BASE_URL}/"
        data = {"gang": gang, "age": age, "bankroll": bankroll}
        response = self.session.post(url, data=data)
        if response.status_code == 200:
            return response
        else:
            print("Ошибка при отправке параметров.")
            exit(1)
        

    def select_cards(self, cards):
        url = f"{self.BASE_URL}/play"
        payload = {"i": cards}
        response = self.session.post(url, data=payload)
        if response.status_code == 200:
            return response
        else:
            print("Ошибка при выборе карт.")
            exit(1)

    def set_bet(self, bet):
        url = f"{self.BASE_URL}/bet"
        payload = {"bet": bet}
        response = self.session.post(url, data=payload)
        if response.status_code == 200:
            return response
        else:
            print("Ошибка при при выборе ставки.")
            exit(1)

    def shuffling(self):
        url = f"{self.BASE_URL}/shuffling"
        response = self.session.get(url)
        if response.status_code == 200:
            return response
        else:
            print("Ошибка при нажатии кнопки.")
            exit(1)
        

    def extract_selected_cards(self, html_content):
        selected_cards = []
        soup = BeautifulSoup(html_content, 'html.parser')
        checkboxes = soup.find_all('input', {'type': 'checkbox'})
        for checkbox in checkboxes:
            card_value = checkbox['value']
            selected_cards.append(card_value)
        return selected_cards
    
    def extract_card_names(self, html_code):
        card_names = []

        soup = BeautifulSoup(html_code, 'html.parser')

        for img_tag in soup.find_all('img', {'src': True}):
            src_value = img_tag['src']
            card_name = src_value.split('/')[-1].split('.')[0]
            card_names.append(card_name)

        return card_names
    
    def next_draw(self):
        url = f"{self.BASE_URL}/bet"
        response = self.session.get(url)
        if response.status_code == 200:
            return response
        else:
            print("Ошибка при нажатии кнопки.")
            exit(1)
    
    def extract_bankroll(self, html_text):

        soup = BeautifulSoup(html_text, 'lxml')
        div_element = soup.find('div', class_='text-1')
        p_content = div_element.find('p').get_text()
        bankroll_text = p_content.split('|')[1]
        bankroll_value = bankroll_text.split(':')[1].strip().replace('€', '')

        return bankroll_value


class Attack:

    def __init__(self):
        self.main_deck = ['2-h','3-h','4-h','5-h','6-h','7-h','8-h','9-h','10-h','J-h','Q-h','K-h','A-h','2-d','3-d','4-d','5-d','6-d','7-d','8-d','9-d','10-d','J-d','Q-d','K-d','A-d','2-c','3-c','4-c','5-c','6-c','7-c','8-c','9-c','10-c','J-c','Q-c','K-c','A-c','2-s','3-s','4-s','5-s','6-s','7-s','8-s','9-s','10-s','J-s','Q-s','K-s','A-s']

    def exclude_elements(self, deck, draw):
        positions = []
        for i in range(len(draw)):
            index = deck.index(draw[i])
            positions.append(int(index))
            deck.pop(index)
        return positions

    def predict_draw(self, state):

        m_deck = [self.main_deck[j] for j in range(len(self.main_deck))]
        LFG = LaggedFibonacciGenerator(m_deck, state)
        draw1 = LFG.first_draw(5)
        draw2 = LFG.second_draw(5)
        state = LFG.get_state()

        return draw1, draw2, state

    def attack(self, draw):

        nums = []
        mods = [i for i in range(len(self.main_deck), len(self.main_deck) - 10, -1)]
        state = []

        for i in range(0, len(draw), 2):
            m_deck = [self.main_deck[j] for j in range(len(self.main_deck))]
            nums = self.exclude_elements(m_deck, draw[i]+ draw[i + 1])

            x = CRT(nums, mods)
            state.append(x)
            
        print("state:", state)
        return state

    def predict_winner(self, draw1, draw2):

        result = []
        for r in range(1, len(draw2) + 1):
            result.extend(comb(draw1, r))

        for r in result:
            draw_final = list(r) + draw2[:5 - len(r)]
            gain, frase = combinations(draw_final, 100)
            if gain > 100:
                print("Возможный выигрыш:", frase, "Позиции:", draw_final)
                return "max", r 

        return "min", draw1
    
    # Выбор карт - 10 раз по 10 (5+5) карт
    def collect_draws(self, response0, bankroll):
   
        response = response0
        draw = []
        for _ in range(10):
            
            response = interaction.set_bet(bankroll//10)
            draw1 = interaction.extract_selected_cards(response.text)
            response = interaction.select_cards([])
            draw2 = interaction.extract_card_names(response.text)
            bankroll = int(interaction.extract_bankroll(response.text))
            response = interaction.next_draw()
            print(f"{_+1}, {bankroll=}")
            draw.append(draw1)
            draw.append(draw2)
        return draw, response, bankroll


if __name__ == "__main__":
    interaction = Interaction()
    attack = Attack()

    # Регистрация
    gang, age, bankroll = "grove street", 18, 9999
    response = interaction.register(gang, age, bankroll)
    bet = 9998

    draw, response, bankroll = attack.collect_draws(response, bankroll)
    state = attack.attack(draw)

    # Начинаем набор очков
    j = 0
    while bankroll < 10000000000:

        print("New state:", state)
        draw1, draw2, state = attack.predict_draw(state)

        result, addition = attack.predict_winner(draw1, draw2)

        if result == "max":
            bet = bankroll - 1
        else:
            bet = bankroll // 10 + 1
            print("Шансов нет, ставим bankroll // 10")

        response = interaction.set_bet(bet)
        assert draw1 == interaction.extract_card_names(response.text)[5:]

        response = interaction.select_cards(list(addition))

        if "vka" in response.text:
            pattern = r'vka\{[A-Za-z0-9_]+\}'
            matches = re.findall(pattern, response.text)
            print("Вы выиграли!", matches[0])
            print(j)
            exit(0)
        bankroll = int(interaction.extract_bankroll(response.text))
        print("Ваш бэнкролл:", bankroll)
        response = interaction.next_draw()
        j+= 1