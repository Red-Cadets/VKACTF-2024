import numpy as np
import tqdm
from pwn import *
import json


class Attack():

    def __init__(self, q, n):
        self.q = q
        self.N = n

    # reduction mod q
    def modNQ(self, a):
        return np.asarray([a[i] % self.q for i in range(self.N)])

    # product mod X^N+1
    def productModN(self, a, b):
        tmp = np.zeros(self.N, int)
        for i in range(self.N):
            for j in range(i):
                tmp[j] -= a[i] * b[self.N+j-i]
            for j in range(i,self.N):
                tmp[j] += a[i] * b[j-i];
        return tmp

    def f(self, s, A1, A3, t1, t2):
        return np.concatenate((self.modNQ(t1 - self.productModN(A1,s)), self.modNQ(t2 - self.productModN(A3,s))), axis=None)

    def g(self, s, A2, A4):
        return np.concatenate((self.modNQ(self.productModN(A2,s)), self.modNQ(self.productModN(A4,s))), axis=None)

    def check(self, u,v):
        for i in range(2*self.N):
            if abs((u[i]-v[i]+125)%self.q-125)>1:
                return False
        return True


    def next_array(self, u):
        for i in range(self.N):
            if (u[i]==0):
                u[i]=1
                return True
            u[i]=0
        return False

    def keyof(self, u0, u1, u2):
        return (u0%self.q) + self.q*(u1%self.q) + self.q*self.q*(u2%self.q)

    def recover_keys(self, pool, A2, A4):
        att_s2=np.zeros(self.N, int)
        for i in tqdm.trange(65536):
            v = self.g(att_s2, A2, A4)
            for x0 in range(-1,2):
                for x1 in range(-1,2):
                    for x2 in range(-1,2):
                        for w in pool[self.keyof(v[0]+x0,v[1]+x1,v[2]+x2)]:
                            if self.check(v,w):
                                return (w[2*self.N:],att_s2)
            self.next_array(att_s2)
        return None
    
    def decode(self, x):
        if ((x+(self.q//4))%self.q) > (self.q//2):
            return 1
        else:
            return 0

def __main__():


    N = 16
    q = 337
    Atck = Attack(q, N)

    pool={}
    for i in tqdm.trange(q*q*q):
        pool[i]=[]

    io = remote('81.94.150.171', 10005)
    io.recvline()

    for i in range(5):
        

        public_key = json.loads(io.recvline())
        ciphertext = json.loads(io.recvline())
        io.recvline()
        io.recvuntil(b'Enter message in binary list: ')

        A1 = public_key['A'][0]
        A2 = public_key['A'][1]
        A3 = public_key['A'][2]
        A4 = public_key['A'][3]

        t1 = public_key['t'][0]
        t2 = public_key['t'][1]

        u1 = ciphertext['u'][0]
        u2 = ciphertext['u'][1]
        v0 = ciphertext['v']

        pool_i = pool

        att_s1=np.zeros(N, int)
        for i in tqdm.trange(65536):
            v = Atck.f(att_s1, A1, A3, t1, t2)
            pool_i[Atck.keyof(v[0],v[1],v[2])].append(np.concatenate((v, att_s1), axis=None))
            Atck.next_array(att_s1)

        (s1,s2) = Atck.recover_keys(pool_i, A2, A4)
        predec = Atck.modNQ(v0 - Atck.productModN(u2,s2) - Atck.productModN(u1,s1))
        decrypted = [(Atck.decode(predec[N-1-i])) for i in range(N)][::-1]

        io.sendline(json.dumps({'m': decrypted}).encode())

        io.recvline()
        print(io.recvline().decode())

    
    io.recvline()
    print(io.recvline().decode())
    print(io.recvline().decode())

    io.close()

__main__()