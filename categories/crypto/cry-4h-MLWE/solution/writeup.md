# Next Genetation

|   C–æ–±—ã—Ç–∏–µ   | –ù–∞–∑–≤–∞–Ω–∏–µ | –ö–∞—Ç–µ–≥–æ—Ä–∏—è | –°–ª–æ–∂–Ω–æ—Å—Ç—å |
| :---------: | :------: | :-------: | :-------: |
| VKACTF 2024 | Next Genetation |  Crypto  |  –°–ª–æ–∂–Ω–∞—è  |

## –û–ø–∏—Å–∞–Ω–∏–µ

>–ê–≤—Ç–æ—Ä: Inssurg3nt
>
>–ö–∏–±–µ—Ä –ø—Ä–µ—Å—Ç—É–ø–Ω–∏–∫–∏ –≤—ã—à–ª–∏ –Ω–∞ –Ω–æ–≤—ã–π —É—Ä–æ–≤–µ–Ω—å, –ø—Ä–∏–¥—É–º–∞–ª–∏ —à–∏—Ñ—Ä –Ω–æ–≤–æ–≥–æ –ø–æ–∫–æ–ª–µ–Ω–∏—è! –ü–æ–∫–∞–∂–∏ –∏–º, –∫—Ç–æ –∫—Ä–∏–ø—Ç–æ–ø–∞–ø–∞ –≤ —ç—Ç–æ–º –≥–æ—Ä–æ–¥–µ!

# –†–µ—à–µ–Ω–∏–µ

–°–º–æ—Ç—Ä–∏–º –≤ –∏—Å—Ö–æ–¥–Ω–∏–∫–∏ –∏ –ø–æ–Ω–∏–º–∞–µ–º, —á—Ç–æ –º—ã –∏–º–µ–µ–º –¥–µ–ª–æ —Å –ø–æ—Å—Ç–∫–≤–∞–Ω—Ç–æ–≤—ã–º –∞–ª–≥–æ—Ä–∏—Ç–º–æ–º [kyber](https://pq-crystals.org/kyber/), –∞ –∏–º–µ–Ω–Ω–æ - –µ–≥–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è baby-kyber, –æ—Ç–ª–∏—á–∞—é—â–∞—è—Å—è –æ—Ç —Å—Ç–∞—Ä—à–µ–≥–æ —Å–æ–±—Ä–∞—Ç–∞ —Ç–æ–ª—å–∫–æ –º–∞–ª–µ–Ω—å–∫–∏–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏. –¢–µ–º –Ω–µ –º–µ–Ω–µ–µ, —Å–ª–æ–∂–Ω–æ—Å—Ç—å –≤—ã—á–∏—Å–ª–µ–Ω–∏–π kyber –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –Ω–µ–ø–ª–æ—Ö—É—é —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å –≤ –ø–æ–ª–Ω–æ–º—É –ø–µ—Ä–µ–±–æ—Ä—É. –¢–µ–º –Ω–µ –º–µ–Ω–µ–µ, –º–æ–∂–Ω–æ –ø—Ä–æ–≤–µ—Å—Ç–∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π –∫—Ä–∏–ø—Ç–æ–∞–Ω–∞–ª–∏–∑. –†–∞–∑–±–µ—Ä–µ–º —Å–ø–ª–æ–∏—Ç –ø–æ–¥—Ä–æ–±–Ω–µ–µ.

```python
import numpy as np

N = 16
q = 337

def modNQ(a):
    return np.asarray([a[i]%q for i in range(N)])

def productModN(a, b):
    tmp = np.zeros(N, int)
    for i in range(N):
      for j in range(i):
        tmp[j] -= a[i] * b[N+j-i]
      for j in range(i,N):
        tmp[j] += a[i] * b[j-i];
    return tmp

# –º–Ω–æ–≥–æ—á–ª–µ–Ω—ã –≤–≤–æ–¥—è—Ç—Å—è –≤ –ø–æ—Ä—è–¥–∫–µ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—è —Å—Ç–µ–ø–µ–Ω–∏
t1 = [82, 185, 301, 278, 199, 129, 4, 90, 141, 230, 123, 294, 251, 67, 66, 155]
t2 = [336, 139, 1, 93, 182, 54, 214, 98, 7, 94, 199, 243, 27, 129, 86, 90]

A1 = [108, 182, 244, 327, 242, 208, 285, 214, 311, 96, 26, 56, 140, 211, 245, 294]
A2 = [9, 23, 231, 66, 323, 222, 259, 322, 145, 247, 71, 291, 297, 255, 175, 83]
A3 = [200, 48, 207, 295, 144, 234, 117, 115, 261, 214, 176, 208, 153, 48, 186, 61]
A4 = [91, 141, 261, 84, 268, 233, 22, 42, 46, 260, 221, 231, 9, 193, 71, 231]

```

–ù–∏–∂–µ –ø—Ä–∏–≤–µ–¥–µ–Ω –ø—Ä–∏–º–µ—Ä –∫–æ–¥–∞ –∫—Ä–∏–ø—Ç–æ–∞–Ω–∞–ª–∏–∑–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–ª–ª–∏–∑–∏–π, –∫–æ—Ç–æ—Ä—ã–π –∏–∑–≤–ª–µ–∫–∞–µ—Ç $s_1$, $s_2$.

![formula](images/image1.png)

–ú—ã –∏—â–µ–º –¥–≤–∞ –±–∏–Ω–∞—Ä–Ω—ã—Ö –º–Ω–æ–≥–æ—á–ª–µ–Ω–∞ $s_1$, $s_2$ —Å—Ç–µ–ø–µ–Ω–∏ 16 s.t. $f(s_1) - g(s_2)$ –∏–º–µ—é—â–∏—Ö –∑–Ω–∞—á–µ–Ω–∏—è $\in \{0,+1\} \mod q$

–¢–æ –µ—Å—Ç—å, —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ $s_1$, $s_2$, —Ç–∞–∫–∏–µ, —á—Ç–æ: $$\textrm{check}(f(s_1),g(s_2))\textrm{ is True}.$$

```python
def f(s):
  return np.concatenate((modNQ(t1 - productModN(A1,s)), modNQ(t2 - productModN(A3,s))), axis=None)

def g(s):
  return np.concatenate((modNQ(productModN(A2,s)), modNQ(productModN(A4,s))), axis=None)

# –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, –æ—Ç–ª–∏—á–∞—é—Ç—Å—è –ª–∏ –¥–≤–∞ 16-–±–∏—Ç–Ω—ã—Ö –≤–µ–∫—Ç–æ—Ä–∞ mod q –Ω–∞ 1,0 
def check(u,v):
  for i in range(2*N):
    if abs((u[i]-v[i]+125)%q-125)>1:
      return False
  return True
```


–ú—ã –º–æ–≥–ª–∏ –±—ã –Ω–∞–ø—Ä—è–º—É—é –ø–µ—Ä–µ—á–∏—Å–ª–∏—Ç—å –ø–∞—Ä—ã $2^{32}$ $Ìë†_1$, $Ìë†_2$, –Ω–æ —ç—Ç–æ –∑–∞–Ω—è–ª–æ –±—ã –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è (–ø—Ä–∏–º–µ—Ä–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ —á–∞—Å–æ–≤).

–ë–æ–ª–µ–µ –ø—Ä–∏–µ–º–ª–µ–º–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∞–ª–≥–æ—Ä–∏—Ç–º-–∫–æ–º–ø—Ä–æ–º–∏—Å—Å –º–µ–∂–¥—É –≤—Ä–µ–º–µ–Ω–µ–º –ø–æ–∏—Å–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π –∏ –æ–±—ä–µ–º–æ–º –ø–∞–º—è—Ç–∏, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Ä–µ—à–µ–Ω–∏–µ –≤—Å–µ–≥–æ –∑–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç:

–ú—ã –ø–µ—Ä–µ—á–∏—Å–ª—è–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ $2^{16}$ ùëì($ùë†_1$) –∏ –∏–Ω–¥–µ–∫—Å–∏—Ä—É–µ–º –∏—Ö –ø–æ –∏—Ö –ø–µ—Ä–≤—ã–º 3 –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º mod ùëû (—Å—É—â–µ—Å—Ç–≤—É–µ—Ç –Ω–µ –±–æ–ª–µ–µ $ ùëû^3$‚âà16 –º–∏–ª–ª–∏–æ–Ω–æ–≤ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤).

```python
# –µ—Å–ª–∏ u - –¥–≤–æ–∏—á–Ω—ã–π –º–Ω–æ–≥–æ—á–ª–µ–Ω —Å—Ç–µ–ø–µ–Ω–∏ N, –∑–∞–º–µ–Ω—è–µ–º –µ–≥–æ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –≤ –ª–µ–∫—Å–∏–∫–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–æ–º –ø–æ—Ä—è–¥–∫–µ.
# —ç—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∏—Ç–µ—Ä–∞—Ü–∏—é –ø–æ 2^16 –¥–≤–æ–∏—á–Ω—ã–º –º–Ω–æ–≥–æ—á–ª–µ–Ω–∞–º.
def next_array(u):
  for i in range(N):
    if (u[i]==0):
      u[i]=1
      return True
    u[i]=0
  return False

# —É—á–∏—Ç—ã–≤–∞—è 3 –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–æ –º–æ–¥—É–ª—é q, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–π –∏–Ω–¥–µ–∫—Å –º–∞—Å—Å–∏–≤–∞
# –ø–æ—Å–∫–æ–ª—å–∫—É –≤ —Å–ª–æ–≤–∞—Ä—è—Ö –ø—Ä–æ—â–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ –∏–Ω–¥–µ–∫—Å—ã.

def keyof(u0,u1,u2):
  return (u0%q) + q*(u1%q) + q*q*(u2%q)

# –¥–ª—è –≤—Å–µ—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç u,v,w –ø–æ –º–æ–¥—É–ª—é q,
#   pool[keyof(u,v,w)] —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ –∫–æ—Ä—Ç–µ–∂–∏ (f(s),s)
#                –≥–¥–µ s –¥–≤–æ–∏—á–Ω—ã–π, –∞ f(s) –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å u,v,w
pool={}
for i in range(q*q*q):
  pool[i]=[]


att_s1=np.zeros(N, int)
for i in range(65536):
  v = f(att_s1)
  pool[keyof(v[0],v[1],v[2])].append(np.concatenate((v, att_s1), axis=None))
  next_array(att_s1)
```

–ù–∞–∫–æ–Ω–µ—Ü, –º—ã –∑–∞–º–µ—á–∞–µ–º, —á—Ç–æ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ $ùë†_2$, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç —Ç–æ–ª—å–∫–æ 8 –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ ùëì($ùë†_1$) –±–ª–∏–∑–∫–æ–µ –∫ ùëî($ùë†_2$): –º—ã –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ—á–∏—Å–ª—è–µ–º —ç—Ç–∏ 8 –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É –Ω–∞—Å —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ.

```Python
def recover_keys():
  att_s2=np.zeros(N, int)
  for i in range(65536):
    v = g(att_s2)
    for x0 in range(-1,2):
      for x1 in range(-1,2):
        for x2 in range(-1,2):
          for w in pool[keyof(v[0]+x0,v[1]+x1,v[2]+x2)]:
            if check(v,w):
              return (w[2*N:],att_s2)
    next_array(att_s2)
  return None

(s1,s2) = recover_keys()
print('Found s2=%s' % s2)
print('Found s1=%s' % s1)
```
Found s2=[1 0 0 0 1 0 1 1 1 0 0 1 0 1 1 1]

Found s1=[1 1 1 1 1 0 1 1 0 0 0 1 0 0 1 1]

–¢–µ–ø–µ—Ä—å, –∫–æ–≥–¥–∞ –º—ã –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–ª–∏ —Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á, –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä!

```python
# —ç—Ç–æ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–µ–∞–Ω—Å–æ–≤—ã–π –∫–ª—é—á
u1 = [248, 8, 13, 94, 167, 51, 116, 18, 36, 7, 163, 36, 46, 303, 53, 76]
u2= [316, 219, 281, 323, 220, 23, 260, 311, 103, 37, 214, 81, 212, 131, 163, 68]
v= [325, 87, 125, 35, 213, 170, 206, 176, 104, 280, 90, 49, 121, 319, 81, 225]
# —ç—Ç–æ —Ñ–∞–∑–∞ –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –ø–µ—Ä–µ–¥ –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ–º
predec = modNQ(v - productModN(u1,s1) - productModN(u2,s2))
```

```python
# —Ñ—É–Ω–∫—Ü–∏—è –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è: –≤—Å–µ, —á—Ç–æ –±–ª–∏–∂–µ –∫ q/2, —á–µ–º –∫ 0 –ø–æ –º–æ–¥—É–ª—é q, –¥–µ–∫–æ–¥–∏—Ä—É–µ—Ç—Å—è –∫–∞–∫ 1,
# –æ—Å—Ç–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–µ–∫–æ–¥–∏—Ä—É–µ—Ç—Å—è –∫–∞–∫ 0
def decode(x):
  if ((x+(q//4))%q) > (q//2):
    return 1
  else:
    return 0

decrypted = [str(decode(predec[N-1-i])) for i in range(N)]

```

–†–µ—à–µ–Ω–∏–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–æ –Ω–∞ —è–∑—ã–∫–µ [Python3](exploit/sploit.py).


### –§–ª–∞–≥

```
vka{3asy_cr4ck_pqc_1n_b4by_kyber}
```